---
title: "Business Logic"
description: ""
icon: "briefcase"
---

There are things that are hard to teach machine learning models. Business logic is the layer to to overrule something in the model.

After the model returns output, Wyvern supports a business layer which allows you to customize and tune the model behavior on purpose.

For example, one important business logic use case in ranking is boosting and burying product. Sometimes, there’s one particular product that you want to promote or demote from your ranking list. For instance, if a product violates your use of terms, wyvern offers you the ability to demote or remove the product from the result even though this product has a good ranking score returned from the model.
Another example - if your analysis shows that occasionally showing new products in the third position really improves new brand conversion without hurting the user experience, it’s also a simple task to force a product to be in the third slot with the business logic layer.

## How It Works

<Frame>
  <img class="w-56" src="/images/business_logic.png" />
</Frame>

[BusinessLogicPipeline](https://docs.wyvern.ai/sdk_ref#businesslogicpipeline-objects) is the representation of a sequeance chain of business logics. Within the BusinessLogicPipeline, you can chain many [BusinessLogicComponent](https://docs.wyvern.ai/sdk_ref#businesslogiccomponent-objects) one after another. BusinessLogicPipeline steps through this series of business logic components and returns the final output

The input to the BusinessLogicPipeline is [BusinessLogicRequest](https://docs.wyvern.ai/sdk_ref#businesslogicrequest-objects). The output of each business logic component is passed as an input to the next business logic component.

### Build a BusinessLogicPipeline

```python
class SearchBusinessLogicPipeline(
    BusinessLogicPipeline[Product, ProductRankingRequest],
):
    def __init__(self):
        super().__init__(
            CandleBoostingBusinessLogicComponent(),
            AlwaysBoostWaxSealProduct(),
            BuryBlockListProducts(),
            name="search_business_logic_pipeline",
        )

search_business_logic_pipeline = SearchBusinessLogicPipeline()
```

In this example, we're building a SearchBusinessLogicPipeline, which your marketplace might use to do the following sequentially:

1. first Boost candel products
2. then boost wax seal products
3. finally bury products in your block lists.

The business logic's target entity type is `Product`. `ProductRankingRequest` is exactly the same request of your ML pipeline.

Now let's look at how a BusinessLogic component `AlwaysBoostWaxSealProduct` is built:

```python
class AlwaysBoostWaxSealProduct(
    BoostingBusinessLogicComponent[
        Product,
        ProductSearchRankingRequest,
    ],
):
    async def execute(
        self,
        input: BusinessLogicRequest[
            Product,
            ProductSearchRankingRequest,
        ],
        **kwargs,
    ) -> List[ScoredCandidate[Product]]:
        return self.boost(input.scored_candidates, entity_keys={"7"}, boost=100)
```

The input of this BusinessLogicComponent, `AlwaysBoostWaxSealProduct`, is BusinessLogicRequest, same as the input of BusinessLogicPipeline, `SearchBusinessLogicPipeline`.

### How to execute business logic

```python
scored_candidates: List[ScoredCandidate] = [
    ScoredCandidate(
        entity=candidate,
        score=(
            model_outputs.data.get(candidate.identifier)
        ),
    )
    for i, candidate in enumerate(request.candidates)
]

business_logic_request = BusinessLogicRequest[
    Product,
    ProductSearchRankingRequest,
](
    request=ranking_request,
    scored_candidates=scored_products,
)

search_business_logic_pipeline = SearchBusinessLogicPipeline()
ranked_products = await search_business_logic_pipeline.execute(
    business_logic_request,
)
```

First you need to build the BusinessLogicRequest with your entity (`Product` in the example), and the request object. In this case, the request is the request of the ranking pipeline and the scored_products is the list of candidates (products) that are scored by the ranking model.

Secondly, build the business logic instance of `SearchBusinessLogicPipeline` and pass the BusinessLogicRequest input to search_business_logic_pipeline.execute to execute the business logic pipeline.

---
title: "Real-time Features"
description: ""
icon: "person-running-fast"
---

## What is a real-time feature?

Real-time features can be used to generate features that are easier to compute and have higher accuracy online than offline. Examples include:

1. Request metadata (user device, user location, etc) — you have 100% accuracy online
2. Embedding similarity (user x product) — Storage complexity is significantly lower if you compute this online
3. “Facts” about entities (ie product name) — Eliminate the risk of stale (recently uploaded) data
4. Real-time Embeddings — Capture the long-tail of queries as embedding the query in real-time gives 100% coverage
5. Session Embeddings — Capture user interactions on the website ahead of this request and personalize content based on that

There is [a great article from Chip Huyen about real-time machine learning](https://huyenchip.com/2023/01/08/self-serve-feature-platforms.html#batch-vs-real-time-vs-nrt-features)

## Wyvern RealtimeFeatureComponent

For a ML feature, there is usually an entity or a composite of entities that the feature is associated to.

Wyvern has the RealtimeFeatureComponent which allows you to inherit from and define the your feature group. It has three potential inputs: the primary entity, the secondary entity and the request entity.

In the ranking example, there are five features. For each feature, we need to define the entity of the feature.

The entity for the search score of the product is obviously the "product". Here's the definition for this feature:

```python pipelines/product_ranking/realtime_features.py
from wyvern.entities.feature_entities import FeatureData
from wyvern.components.features.realtime_features_component import (
    RealtimeFeatureComponent,
)
from wyvern.wyvern_typing import WyvernFeature


class RealtimeProductFeature(RealtimeFeatureComponent[Product, Any, Any]):
    def __init__(self):
        super().__init__(
            output_feature_names={
                "search_score",
            },
        )

    async def compute_features(
        self,
        primary_entity: Product,
        request: Any,
    ) -> Optional[FeatureData]:
        features: dict[str, WyvernFeature] = {
            "search_score": primary_entity.search_score or 0.0,
        }

        return FeatureData(
            identifier=primary_entity.identifier,
            features=features,
        )
```

For the reset of features, they're all about similarity between the query and a product feature. This is what we call the "CompositeEntity" where the feature is the composite of two features of two different entities. Here's the definition of the composite feature group:

```python pipelines/product_ranking/realtime_features.py
from wyvern.entities.identifier_entities import QueryEntity


class RealtimeProductQueryFeature(
    RealtimeFeatureComponent[Product, QueryEntity, Any],
):
    def __init__(self):
        super().__init__(
            output_feature_names={
                "search_score",
                "query_category_similarity",
                "query_brand_similarity",
                "query_title_similarity",
                "query_description_similarity",
            },
        )

    async def compute_composite_features(
        self,
        primary_entity: Product,
        secondary_entity: QueryEntity,
        request: Any,
    ) -> Optional[FeatureData]:
        # compute the potential categories for the query.
        # In another word, given a query, what are the possible categories
        #   that the query is referring to with top 3 probability.
        # For example, if the query is "iphone", the top 3 categories could be "iphone", "iphone case", "iphone charger"

        features: dict[str, WyvernFeature] = {
            "query_category_similarity": random.random(),
            "query_brand_similarity": random.random(),
            "query_title_similarity": random.random(),
            "query_description_similarity": random.random(),
        }

        return FeatureData(
            identifier=CompositeIdentifier(
                primary_entity.identifier,
                secondary_entity.identifier,
            ),
            features=features,
        )
```

## Register Realtime Features

Now we go back to the `pipelines/main.py` and register the realtime features with Wyvern service:

```python pipelines/main.py
from wyvern.service import WyvernService

from pipelines.product_ranking.realtime_features import (
    RealtimeProductFeature,
    RealtimeProductQueryFeature,
)

app = WyvernService.generate_app(
    realtime_feature_components=[RealtimeProductFeature, RealtimeProductQueryFeature],
)
```

To register realtime features, pass the realtime_feature_components, containing the list of your realtime features, to `WyvernService.generate_app`. This basically tells the Wyvern service that these are available realtime features ready.

Now that all the batch/offline features and realtime features are ready, let's look at how to define the models.
